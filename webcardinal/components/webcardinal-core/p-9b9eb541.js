import{s as e,u as n,B as t,z as o,k as s,x as a,y as i,t as r,r as l,o as c,n as f,m as d}from"./p-2c4422ec.js";import{F as u,d as h,l as m,m as b,n as p,o as x,k as v,e as $,p as y,q as M,I as A,s as j,t as g,g as w,J as P,i as E,b as C,j as O,V as T,D as k,h as N}from"./p-306a0f7f.js";import{c as V,d as W}from"./p-e506992e.js";function B(n,t,o){const s=t.getChainValue(o);if(s){for(const[t,o]of Object.entries(s))e(n,{key:t,value:o});if(!0===s._saveElement){for(const e in n)"function"==typeof n[e]&&(n[e]=n[e].bind(n));s.getElement||t.setChainValue(o,Object.assign(Object.assign({},s),{getElement:()=>n}))}}if(t.hasExpression(o)){const s=t.evaluateExpression(o);for(const[t,o]of Object.entries(s))e(n,{key:t,value:o})}}function I(e){return e.nodeType===Node.ELEMENT_NODE}function q(e){return e.nodeType===Node.TEXT_NODE&&e.nodeValue&&e.nodeValue.trim()}function z(e,t,o,s=null){if(w.includes(e.nodeName.toLowerCase()))return;if(e.nodeType!==Node.TEXT_NODE||!e.nodeValue||!e.nodeValue.trim())return;const r=[...e.nodeValue.matchAll(/\{\{\s*([^\s}}]+)\s*\}\}/g)];if(!r.length)return;const l=r.map((e=>({expression:e[0],chainWithPrefix:e[1]}))).filter((({chainWithPrefix:e})=>e.startsWith(h)||e.startsWith($))).map((e=>{let{chainWithPrefix:a}=e;const i=a.startsWith($);let r=e.chainWithPrefix.slice(1);!i&&s&&(r=n(s,r),a=`${h}${r}`);const l=i?o:t;return Object.assign(Object.assign({},e),{chain:r,isTranslation:i,isModel:!i,isModelExpression:l.hasExpression(r),evaluateModelExpression:()=>l.evaluateExpression(r),model:l,getChainValue:()=>{let e=l.getChainValue(r);if(i&&void 0===e){const{pathname:n}=window.location,t=P();console.warn(`No translations found for skin "${t}", page "${n}" and chain "${r}"`),e=r}return e}})}));if(!l.length)return;const c=e.nodeValue,f=()=>{let n=c;l.forEach((({expression:e,getChainValue:t,isModelExpression:o,evaluateModelExpression:s})=>{let a=t();["number","boolean"].includes(typeof a)&&(a=a.toString()),!a&&o&&(a=o?s():""),n=n.replace(e,a||"")})),e.nodeValue=n};f(),l.filter((e=>e.isModel)).forEach((({model:n,chain:t,isModelExpression:o})=>{const s=()=>{f()};if(n.onChange(t,s),a(e,t,s),o){const o=()=>{f()};n.onChangeExpressionChain(t,o),i(e,t,o)}}))}const D={bindElement:(e,P={model:null,translationModel:null})=>{const{model:F,translationModel:J,chainPrefix:S,enableTranslations:U=!1,recursive:G=!1}=P;if(F){if(q(e))z(e,F,J,S);else if(I(e)){const H=e;if(window.WebCardinal.components.tags.has(H.tagName.toLowerCase()))return;if(w.includes(H.tagName.toLowerCase()))return s(H,F,h,S);if(H.hasAttribute(E)){let e;H.hasAttribute(C)&&(e=H.getAttribute(C),(null==e?void 0:e.startsWith(h))&&(e=e.slice(1)));const t=n(S,e);H[O]=()=>F.hasExpression(t)?F.evaluateExpression(t):F.toObject(t)}const K=f(H,A),L=f(H,u);if(K&&L)console.error("Cannot use both data-if and data-for attributes on the same element",H);else if(K)!function(e,t,{model:o,translationModel:f,chainPrefix:d,enableTranslations:u=!1}={model:null,translationModel:null}){let m=e.getAttribute(A);if(!m.startsWith(h))return void console.warn(`Attribute "${A}" doesn't start with the chain prefix!`);m=m.slice(1);const b=n(d,m),p=Array.from(e.children);let x,v=c(p,j);const y=c(p,g);v.length||y.length||(v=Array.from(e.childNodes)),r(e,o);const M=async n=>{let s;if(n instanceof Promise)try{s=await n}catch(e){console.error("data-if condition promise failed",e),s=!1}else s=!!n;const a=x!==s;x=s,a&&(()=>{const n=x?v:y;r(e,o),n.forEach((n=>{const s=n.cloneNode(!0);l(s),e.appendChild(s),t(s,{model:o,translationModel:f,chainPrefix:d,enableTranslations:u,recursive:!0})}))})()};if(M(o.getChainValue(b)),s(e,o,h,d),u&&s(e,f,$,d),o.hasExpression(b)){M(o.evaluateExpression(b));const n=()=>{M(o.evaluateExpression(b))};o.onChangeExpressionChain(b,n),i(e,b,n)}else{const n=()=>{M(o.getChainValue(b))};o.onChange(b,n),a(e,b,n)}}(H,D.bindElement,P);else if(L)!function(e,c,{model:f,translationModel:d,chainPrefix:A,enableTranslations:j=!1}={model:null,translationModel:null}){let g=e.getAttribute(u);if(!g.startsWith(h))return void console.warn(`Attribute "${u}" doesn't start with the chain prefix!`);g=g.slice(1);const w=n(A,g);let P=f.getChainValue(w);if(!Array.isArray(P))return void console.error(`Attribute "${u}" (${g}) must be a chain to an array in the model!`,e);let E=P.length;const C=(e.getAttribute(m)||"").split(" ").filter(String),O=C.includes(b),T=C.includes(p),k=C.includes(x),N=[],B=[];for(t(e,w);e.childNodes.length>0;){const n=e.childNodes[0];I(n)&&n.getAttribute("slot")===v?N.push(n):B.push(n),o(n,f),n.remove()}let q=[];const z=()=>{if(!E)return r(e,f),void N.forEach((n=>{const t=n.cloneNode(!0);l(t),e.appendChild(t),c(t,{model:f,translationModel:d,chainPrefix:A,enableTranslations:j,recursive:!0})}));if(k){const n=document.createElement(e.tagName),t=Array.prototype.slice.call(e.attributes);let o;for(;o=t.pop();)o.nodeName!==m&&n.setAttribute(o.nodeName,o.nodeValue);C.length>0&&n.setAttribute(m,C.join(" ")),e.insertAdjacentElement("afterend",n),e.remove(),e=n}P.forEach(((t,o)=>{const s=[];B.forEach((e=>{const t=e.cloneNode(!0),a=n(w,o);c(t,{model:f,translationModel:d,chainPrefix:a,enableTranslations:j,recursive:!0}),s.push(t)})),q[o]?s.forEach(((e,n)=>{document.createElement("div").appendChild(q[o][n].cloneNode(!0));const t=V(e),s=V(q[o][n]);W(t,s,q[o][n])})):(s.forEach((n=>{e.appendChild(n)})),q[o]=s)}));for(let e=E;e<q.length;e++)q[e].forEach((e=>{r(e,f),e.remove()}));q.splice(E)},D=(n,t=!1)=>{Array.isArray(n)||(console.error(`Attribute "${u}" must be an array in the model!`),n=[]);const o=E!==(n=n||[]).length;if(P=n,E=P.length,T)return z(),void(O&&e.dispatchEvent(new CustomEvent(y)));(t||o)&&(r(e,f),q=[],z(),O&&e.dispatchEvent(new CustomEvent(M)))};z(),s(e,f,h,A),j&&s(e,d,$,A);const F=({targetChain:e})=>{const n=w===e;D(f.getChainValue(w),n)};if(f.onChange(w,F),a(e,w,F),f.hasExpression(w)){const n=()=>{D(f.evaluateExpression(w))};f.onChangeExpressionChain(w,n),i(e,w,n)}}(H,D.bindElement,P);else{const e=H.hasAttribute(T),t=H.hasAttribute(C);if(!H.hasAttribute(k)){if(e||t){let o;if(e?o=H.getAttribute(T):(console.warn(`Attribute "${C}" is deprecated for binding! Use the "${T}" key attribute instead.`,H),o=H.getAttribute(C)),o.startsWith(h)){o=o.slice(1);const e=n(S,o);H.setAttribute(T,`${h}${e}`),t&&H.setAttribute(C,`${h}${e}`),B(H,F,e),d(H,F,e);const s=()=>B(H,F,e);if(F.onChange(e,s),a(H,o,s),F.hasExpression(e)){const n=()=>B(H,F,e);F.onChangeExpressionChain(e,n),i(H,e,n)}}else console.warn(`Invalid chain found! (chain: "${o}")!\n`,`A valid chain must start with "${h}".\n`,"target element:",H)}H.tagName.startsWith(N.toUpperCase())||s(H,F,h,S),U&&s(H,J,$,S),Array.from(H.childNodes).filter(q).forEach((e=>{z(e,F,J,S)}))}G&&Array.from(H.children).forEach((e=>{D.bindElement(e,P)}))}}}else{const n=I(e)?e.tagName.toLowerCase():"text node";console.warn(`No model found for: ${n}!`)}},bindChildNodes:(e,n)=>{Array.from(e.childNodes).forEach((e=>{D.bindElement(e,Object.assign({},n))}))}};export{D as B,I as a,q as i}